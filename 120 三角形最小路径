方法一：动态规划
思路与算法
我们用 f[i][j] 表示从三角形顶部走到位置 (i, j) 的最小路径和。这里的位置 (i, j)指的是三角形中第 i行第 j 列（均从 0 开始编号）的位置。

由于每一步只能移动到下一行「相邻的节点」上，因此要想走到位置 (i, j)，上一步就只能在位置 (i - 1, j - 1) 或者位置 (i - 1, j)。
我们在这两个位置中选择一个路径和较小的来进行转移，状态转移方程为：
f[i][j]=min(f[i−1][j−1],f[i−1][j])+c[i][j]
其中 c[i][j] 表示位置 (i, j) 对应的元素值。

注意第 i 行有 i+1 个元素，它们对应的 j 的范围为 [0, i]。当 j=0 或 j=i 时，上述状态转移方程中有一些项是没有意义的。

例如当 j=0时，f[i-1][j-1] 没有意义，因此状态转移方程为：
f[i][0] = f[i-1][0] + c[i][0]
即当我们在第 i 行的最左侧时，我们只能从第 i-1 行的最左侧移动过来。

当 j=i 时，f[i-1][j] 没有意义，因此状态转移方程为：
f[i][i] = f[i-1][i-1] + c[i][i]
即当我们在第 i 行的最右侧时，我们只能从第 i-1行的最右侧移动过来。

最终的答案即为 f[n-1][0]到 f[n-1][n-1] 中的最小值，其中 n 是三角形的行数。

细节
状态转移方程的边界条件是什么？由于我们已经去除了所有「没有意义」的状态，因此边界条件可以定为：
f[0][0] = c[0][0]

即在三角形的顶部时，最小路径和就等于对应位置的元素值。这样一来，我们从 11 开始递增地枚举 ii，并在 [0, i][0,i] 的范围内递增地枚举 jj，就可以完成所有状态的计算。
class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        vector<vector<int>> f(n, vector<int>(n));
        f[0][0] = triangle[0][0];//初始值
        for (int i = 1; i < n; ++i) {
            f[i][0] = f[i - 1][0] + triangle[i][0];//最左端时只能从i-1行得到
            for (int j = 1; j < i; ++j) {
                f[i][j] = min(f[i - 1][j - 1], f[i - 1][j]) + triangle[i][j];
            }
            f[i][i] = f[i - 1][i - 1] + triangle[i][i];//最右端时只能从最左端得到
        }
        return *min_element(f[n - 1].begin(), f[n - 1].end());//求取路径的饿最小值
    }
};
时间复杂度：O(n^2)，其中 nn 是三角形的行数。
空间复杂度：O(n^2)。我们需要一个 n*n 的二维数组存放所有的状态。

方法二;动态规划+空间优化
从 i 到 0 递减地枚举 j，这样我们只需要一个长度为 n 的一维数组 f，就可以完成状态转移。
为什么只有在递减地枚举 j 时，才能省去一个一维数组？当我们在计算位置 (i, j) 时，f[j+1] 到 f[i] 已经是第 i 行的值，而 f[0] 到 f[j]仍然是第 i-1行的值。此时我们直接通过
f[j]=min(f[j−1],f[j])+c[i][j]
进行转移，恰好就是在 (i-1, j-1)和 (i-1, j)中进行选择。但如果我们递增地枚举 j，那么在计算位置 (i, j) 时，f[0]f[0] 到 f[j-1]f[j−1] 已经是第 ii 行的值。如果我们仍然使用上述状态转移方程，那么是在 (i, j-1)(i,j−1) 和 (i-1, j)(i−1,j) 中进行选择，就产生了错误。

class Solution {
public:
    int minimumTotal(vector<vector<int>>& triangle) {
        int n = triangle.size();
        // 一维数组dp记录遍历到每一行的每个节点的最小路径和
        vector<int> dp(n);
        // 初始化
        dp[0] = triangle[0][0];
        for(int i = 1; i < n; i++)
        {
            // 每一行最右侧的元素
            dp[i] = dp[i - 1] + triangle[i][i];
            for(int j = i - 1; j > 0; j--)
                dp[j] = min(dp[j - 1], dp[j]) + triangle[i][j];
            // 每一行最左侧的元素
            dp[0] += triangle[i][0];
        }
        // 返回dp的最小值
        return *min_element(dp.begin(), dp.end());
    }
};
