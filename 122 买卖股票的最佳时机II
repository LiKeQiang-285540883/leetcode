动态规划：
第 1 步：定义状态
状态 dp[i][j] 定义如下

第一维 i 表示索引为 i 的那一天（具有前缀性质，即考虑了之前天数的收益）能获得的最大利润；
第二维 j 表示索引为 i 的那一天是持有股票，还是持有现金。这里 0 表示持有现金（cash），1 表示持有股票（stock）。

第 2 步：思考状态转移方程
状态从持有现金（cash）开始，到最后一天我们关心的状态依然是持有现金（cash）；
每一天状态可以转移，也可以不动。状态转移用下图表示：

说明：
因为不限制交易次数，除了最后一天，每一天的状态可能不变化，也可能转移；
写代码的时候，可以不用对最后一天单独处理，输出最后一天，状态为 0 的时候的值即可。

第 3 步：确定起始
起始的时候：
如果什么都不做，dp[0][0] = 0；
如果买入股票，当前收益是负数，即 dp[0][1] = -prices[i]；

第 4 步：确定终止
终止的时候，上面也分析了，输出 dp[len - 1][0]，因为一定有 dp[len - 1][0] > dp[len - 1][1]。


class Solution {
public:
    int maxProfit(vector<int>& prices) {
        if(prices.empty()) return 0;
        int n=prices.size();
        vector<vector<int>>dp(n,vector<int>(2));
        dp[0][0]=0;
        dp[0][1]=-prices[0];
        for(int i=1;i<n;i++)
        {
            //可以进行多次交易
            dp[i][0]=max(dp[i-1][0],dp[i-1][1]+prices[i]);//未持有股票状态:上一状态也没有，不操作，上一状态有，然后卖掉
            dp[i][1]=max(dp[i-1][1],dp[i-1][0]-prices[i]);//持有股票状态:上一状态有股票，不操作。没有股票，又买入，所以可以持有股票
        }
        return dp[n-1][0];
    }
};
