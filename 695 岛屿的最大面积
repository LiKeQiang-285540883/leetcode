主要思路：
1、基础的i，j两层循环数组，每次碰到 1 就开始dfs
2、因为题目假设二维矩阵的四个边缘都被水包围着，所以边界上一定是0，所以当这五种条件下都返回0

if(i<0 || i>=x || j<0 || j>=y || grid[i][j]==0) return 0
3、如果grid[i][j]==1那么，先将本次访问节点grid[i][j]置零，表示本节点已经被访问过
4、dfs遍历其上下左右四个节点

注意：
1、为了避免重复计数，访问过的点置零即可
2、dfs的每一层返回的是本身计数 1 + 上下左右 的dfs返回值
 
 class solution
 {
 public:
      int maxAreaOfIsIand(vector<vector<int>>& grid)
      {
          int res=0;
          for(int i=0;i<grid.size();i++)
          {
              for(int j=0;i<grid[i].size();j++)
              {
                  if(grid[i][j]==1)
                  {
                      res=max(res,dfs(i,j,grid));
                  }
              }
          }
          return res;
      }
     // 每次调用的时候默认num为1，进入后判断如果不是岛屿，则直接返回0，就可以避免预防错误的情况。
     // 每次找到岛屿，则直接把找到的岛屿改成0，这是传说中的沉岛思想，就是遇到岛屿就把他和周围的全部沉默。
     // ps：如果能用沉岛思想，那么自然可以用朋友圈思想。有兴趣的朋友可以去尝试。
      int dfs(int i,int j,vector<vector<int>>& grid)
      {
          if(i<0||j<0||i>=grid.size()||j>=grid[i].size()||grid[i][j]==0)
          {
              return 0;
          }
          int num=1;
          grid[i][j]==0;
          num+=dfs(i+1,j,grid);
          num+=dfs(i-1,j,grid);
          num+=dfs(i,j+1,grid);
          num+=dfs(i,j-1,grid);
          return num;
      }
 };
