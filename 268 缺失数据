方法三：位运算

分析
由于异或运算（XOR）满足结合律，并且对一个数进行两次完全相同的异或运算会得到原来的数，因此我们可以通过异或运算找到缺失的数字。

算法
我们知道数组中有 n 个数，并且缺失的数在 [0..n] 中。因此我们可以先得到 [0..n] 的异或值，再将结果对数组中的每一个数进行一次异或运算。
未缺失的数在 [0..n] 和数组中各出现一次，因此异或后得到 0。而缺失的数字只在 [0..n] 中出现了一次，在数组中没有出现，因此最终的异或结果即为这个缺失的数字。
class Solution {
public:
    int missingNumber(vector<int>& nums) {
        //取nums.length为初始值（因为数组缺少1个，取数组长度循环时正好兼顾最后一个值），
        //依次与数组元素和数组索引异或运算，剩下的就是缺失的数字。
        int res=nums.size();
        for(int i=0;i<nums.size();i++)
        {
            res=res^i^nums[i];
        }
        return res;
    }
};
