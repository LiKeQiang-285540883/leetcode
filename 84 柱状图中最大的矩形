/*方法四：单调栈
        维护一个栈，一开始把-1放入栈中来表示开始，初始化时，按照从左到右的顺序，不断的将柱子的序号
        放入栈中，直到遇到相邻主子呈下降关系，也就是heights[i-1]>heights[i]。然后开始将栈中的序号弹出
        直到遇到stack[j]满足heights[stack[j]]=<heights[i]。每次弹出下标时，用弹出的元素作为高，形成
        的最大面积的宽是当前元素与stack[top-1]之间的那些柱子。也就是弹出stack[top]时，记当前元素在原数组
        中的下标为i，当前弹出元素为高的最大矩形面积为：
                                        heights[stack[top]]*(i-stack[top-1]-1)
        精髓在于：栈中存储的是heights的序号，也就是索引下标，这些序号对应到heights中值为依次递增，
                 这个很关键，而且这个-1作为赋值很精髓。
*/
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {        
        stack<int> st;
        heights.push_back(0);
        int size = heights.size();
        int res = 0;
        for (int i = 0; i < size; ++i) {
            while (!st.empty() && heights[st.top()] >= heights[i]) {
                int val = st.top();
                st.pop();
                res = max(res, heights[val] * (st.empty() ? i : (i - st.top() - 1)));
            }
            st.push(i);
        }
        return res;
    }
};
