前言：
    ？可以匹配任何单个字符，和正则题的'.'的作用一样。
    *可以匹配任意字符串（包括空的字符串），和前面的字符没有管子，正则题是和前面的有关系，可以多次重复。
解题思路：
    假定主串 A 的长度为 n，通配串 B 的长度为 m，和正则题一样写，依旧是看通配串 B 中最后一个字符，它有三种可能：
    1、如果 B 的最后一个字符是正常字符，那就是看 A[n-1] 是否等于 B[m-1]，相等则看 A{0..n-2}与 B_{0..m-2}，不等则是不能匹配，这就是子问题。
    2、如果 B 的最后一个字符是?，它能匹配任意字符，直接看 A_{0..n-2}与 B_{0..m-2}，这个和上面的可以合并
    3、如果B的最后一个字符是 * ，有两种情况
       情况一：视作匹配 0 个，B 这个位置的 * 直接废掉，A 不动，B 动
       情况二：匹配 1 个再走，A 动，B 不动
转移方程：
    f[i][j] 代表 A 的前 i 个和 B 的前 j 个字符能否匹配
    对于前面两个情况，可以合并成一种情况 f[i][j] = f[i-1][j-1]
    对于第三种情况，分为匹配 0 个和匹配 1 个两种情况
    匹配 0 个：A 不动，B 动，直接砍掉通配串的最后一个，B 的最后一个 * 废了，只要看 A 的前 i 个和 B 的前 j−1 个能否匹配，即f[i][j] = f[i][j-1]
    匹配 1 个：A 动，B 不动，A 的前 i-1个和 B 的前 j 个能否匹配，即f[i][j] = f[i-1][j]。这里 B 的最后一个是可以用多次的，可以认为它能匹配多次，这里匹配一次只是就这一步而言。
初始条件：
    特判：需要考虑空串空正则
         空主串和空通配串是匹配的，f[0][0] = true
         空主串和非空通配串，不能直接定义 true 和 false，必须要计算出来。
         非空主串和空通配串必不匹配，f[1][0]=...=f[n][0]=false
         非空主串和非空通配串，那肯定是需要计算的了。
         
         大体上可以分为空通配串和非空通配串两种，空通配串也是比较好处理的，对非空通配串我们肯定需要计算，
         非空通配的三种情况，前面两种可以合并到一起讨论，第三种情况是单独一种，那么也就是分为当前位置是 ∗ 和不是 * 两种情况了。
结果：
    开数组要开 n+1 ，这样对于空串的处理十分方便。结果就是 f[n][m]，时间复杂度 O(NM)，空间复杂度 O(NM)
class solution{
public:
      bool isMatch(string s, string p) {
          int m=s.size();
          int n=p.size();
          vector<vector<int>>dp(m+1,vector<int>(n+1));
          dp[0][0]=true;
          for(int i=1;i<=n;i++)
          {
              if(p[i-1]=='*')
              {
                  dp[0][i]=true;
              }
              else
              {
                  break;
              }
          }
          for(int i=1;i<=m;i++)
          {
              for(int i=1;i<=n;i++)
              {
                   if(s[i-1]==p[i-1]||p[i-1]=='?')
                   {
                        dp[i][j]=dp[i-1][j-1];
                   }
                   else if(p[j-1]=='*')
                   {
                        dp[i][j]=dp[i-1][j]|dp[i][j-1];
                   }                   
              }
          }
          return dp[m][n];
          }
};
